<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Sun Mar 24 01:33:39 2019 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>PRINTF(3) BSD Library Functions Manual PRINTF(3)</p>

<p style="margin-top: 1em"><b>NAME</b></p>

<p style="margin-left:6%;"><b>printf</b>, <b>fprintf</b>,
<b>sprintf</b>, <b>snprintf</b>, <b>asprintf</b>,
<b>dprintf</b>, <b>vprintf</b>, <b>vfprintf</b>,
<b>vsprintf</b>, <b>vsnprintf</b>, <b>vasprintf</b>,
<b>vdprintf</b> &mdash; formatted output conversion</p>

<p style="margin-top: 1em"><b>LIBRARY</b></p>

<p style="margin-left:6%;">Standard C&nbsp;Library (libc,
&minus;lc)</p>

<p style="margin-top: 1em"><b>SYNOPSIS</b></p>

<p style="margin-left:6%;"><b>#include
&lt;stdio.h&gt;</b></p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>printf</b>(<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>...</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>fprintf</b>(<i>FILE&nbsp;*&nbsp;restrict&nbsp;stream</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>...</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>sprintf</b>(<i>char&nbsp;*&nbsp;restrict&nbsp;str</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>...</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>snprintf</b>(<i>char&nbsp;*&nbsp;restrict&nbsp;str</i>,
<i>size_t&nbsp;size</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>...</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>asprintf</b>(<i>char&nbsp;**ret</i>,
<i>const&nbsp;char&nbsp;*format</i>, <i>...</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>dprintf</b>(<i>int&nbsp;fd</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>...</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><b>#include
&lt;stdarg.h&gt;</b></p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>vprintf</b>(<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>va_list&nbsp;ap</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>vfprintf</b>(<i>FILE&nbsp;*&nbsp;restrict&nbsp;stream</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>va_list&nbsp;ap</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>vsprintf</b>(<i>char&nbsp;*&nbsp;restrict&nbsp;str</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>va_list&nbsp;ap</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>vsnprintf</b>(<i>char&nbsp;*&nbsp;restrict&nbsp;str</i>,
<i>size_t&nbsp;size</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>va_list&nbsp;ap</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>vasprintf</b>(<i>char&nbsp;**ret</i>,
<i>const&nbsp;char&nbsp;*format</i>,
<i>va_list&nbsp;ap</i>);</p>

<p style="margin-left:6%; margin-top: 1em"><i>int</i></p>


<p style="margin-left:12%;"><b>vdprintf</b>(<i>int&nbsp;fd</i>,
<i>const&nbsp;char&nbsp;*&nbsp;restrict&nbsp;format</i>,
<i>va_list&nbsp;ap</i>);</p>

<p style="margin-top: 1em"><b>DESCRIPTION</b></p>

<p style="margin-left:6%;">The <b>printf</b>() family of
functions produces output according to a <i>format</i> as
described below. The <b>printf</b>() and <b>vprintf</b>()
functions write output to stdout, the standard output
stream; <b>fprintf</b>() and <b>vfprintf</b>() write output
to the given output <i>stream</i>; <b>dprintf</b>() and
<b>vdprintf</b>() write output to the given file descriptor;
<b>sprintf</b>(), <b>snprintf</b>(), <b>vsprintf</b>(), and
<b>vsnprintf</b>() write to the character string <i>str</i>;
and <b>asprintf</b>() and <b>vasprintf</b>() dynamically
allocate a new string with malloc(3).</p>

<p style="margin-left:6%; margin-top: 1em">These functions
write the output under the control of a <i>format</i> string
that specifies how subsequent arguments (or arguments
accessed via the variable-length argument facilities of
stdarg(3)) are converted for output.</p>

<p style="margin-left:6%; margin-top: 1em">The
<b>asprintf</b>() and <b>vasprintf</b>() functions set
<i>*ret</i> to be a pointer to a buffer sufficiently large
to hold the formatted string. This pointer should be passed
to free(3) to release the allocated storage when it is no
longer needed. If sufficient space cannot be allocated,
<b>asprintf</b>() and <b>vasprintf</b>() will return
&minus;1 and set <i>ret</i> to be a NULL pointer.</p>

<p style="margin-left:6%; margin-top: 1em">The
<b>snprintf</b>() and <b>vsnprintf</b>() functions will
write at most <i>size</i>&minus;1 of the characters printed
into the output string (the <i>size</i>&rsquo;th character
then gets the terminating &lsquo;\0&rsquo;); if the return
value is greater than or equal to the <i>size</i> argument,
the string was too short and some of the printed characters
were discarded. The output is always null-terminated, unless
<i>size</i> is 0.</p>

<p style="margin-left:6%; margin-top: 1em">The
<b>sprintf</b>() and <b>vsprintf</b>() functions effectively
assume a <i>size</i> of INT_MAX + 1.</p>

<p style="margin-left:6%; margin-top: 1em">The format
string is composed of zero or more directives: ordinary
characters (not <b>%</b>), which are copied unchanged to the
output stream; and conversion specifications, each of which
results in fetching zero or more subsequent arguments. Each
conversion specification is introduced by the <b>%</b>
character. The arguments must correspond properly (after
type promotion) with the conversion specifier. After the
<b>%</b>, the following appear in sequence:</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">An optional field, consisting
of a decimal digit string followed by a <b>$</b>, specifying
the next argument to access. If this field is not provided,
the argument following the last argument accessed will be
used. Arguments are numbered starting at <b>1</b>. If
unaccessed arguments in the format string are interspersed
with ones that are accessed the results will be
indeterminate.</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">Zero or more of the following
flags:</p>

<p style="margin-top: 1em">&lsquo;<b>#</b>&rsquo;</p>

<p style="margin-left:28%; margin-top: 1em">The value
should be converted to an &lsquo;&lsquo;alternate
form&rsquo;&rsquo;. For <b>c</b>, <b>d</b>, <b>i</b>,
<b>n</b>, <b>p</b>, <b>s</b>, and <b>u</b> conversions, this
option has no effect. For <b>o</b> conversions, the
precision of the number is increased to force the first
character of the output string to a zero. For <b>x</b> and
<b>X</b> conversions, a non-zero result has the string
&lsquo;0x&rsquo; (or &lsquo;0X&rsquo; for <b>X</b>
conversions) prepended to it. For <b>a</b>, <b>A</b>,
<b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, and
<b>G</b> conversions, the result will always contain a
decimal point, even if no digits follow it (normally, a
decimal point appears in the results of those conversions
only if a digit follows). For <b>g</b> and <b>G</b>
conversions, trailing zeros are not removed from the result
as they would otherwise be.</p>

<p style="margin-top: 1em">&lsquo; <b><br>
0</b>&rsquo; (zero)</p>

<p style="margin-left:28%; margin-top: 1em">Zero padding.
For all conversions except <b>n</b>, the converted value is
padded on the left with zeros rather than blanks. If a
precision is given with a numeric conversion (<b>d</b>,
<b>i</b>, <b>o</b>, <b>u</b>, <b>i</b>, <b>x</b>, and
<b>X</b>), the <b>0</b> flag is ignored.</p>


<p style="margin-top: 1em">&lsquo;<b>&minus;</b>&rsquo;</p>

<p style="margin-left:28%; margin-top: 1em">A negative
field width flag; the converted value is to be left adjusted
on the field boundary. Except for <b>n</b> conversions, the
converted value is padded on the right with blanks, rather
than on the left with blanks or zeros. A <b>&minus;</b>
overrides a <b>0</b> if both are given.</p>

<p style="margin-top: 1em">&lsquo;&nbsp;&rsquo; (space)</p>

<p style="margin-left:28%; margin-top: 1em">A blank should
be left before a positive number produced by a signed
conversion (<b>a</b>, <b>A</b>, <b>d</b>, <b>e</b>,
<b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, <b>G</b>, or
<b>i</b>).</p>

<p style="margin-top: 1em">&lsquo;<b>+</b>&rsquo;</p>

<p style="margin-left:28%; margin-top: 1em">A sign must
always be placed before a number produced by a signed
conversion. A <b>+</b> overrides a space if both are
used.</p>

<p style="margin-top: 1em">&lsquo; <br>
&rsquo;&rsquo; (apostrophe)</p>

<p style="margin-left:28%;">Decimal conversions (<b>d</b>,
<b>u</b>, or <b>i</b>) or the integral portion of a floating
point conversion (<b>f</b> or <b>F</b>) should be grouped
and separated by thousands using the non-monetary separator
returned by localeconv(3).</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">An optional decimal digit
string specifying a minimum field width. If the converted
value has fewer characters than the field width, it will be
padded with spaces on the left (or right, if the
left-adjustment flag has been given) to fill out the field
width.</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">An optional precision, in the
form of a period <b>.</b> followed by an optional digit
string. If the digit string is omitted, the precision is
taken as zero. This gives the minimum number of digits to
appear for <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>,
and <b>X</b> conversions, the number of digits to appear
after the decimal-point for <b>a</b>, <b>A</b>, <b>e</b>,
<b>E</b>, <b>f</b>, and <b>F</b> conversions, the maximum
number of significant digits for <b>g</b> and <b>G</b>
conversions, or the maximum number of characters to be
printed from a string for <b>s</b> conversions.</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">An optional length modifier,
that specifies the size of the argument. The following
length modifiers are valid for the <b>d</b>, <b>i</b>,
<b>n</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b>
conversion:</p>

<p style="margin-left:101%; margin-top: 1em"><b>Modifier
d</b>, <b>i o</b>, <b>u</b>, <b>x</b>, <b>X n <br>
hh</b> <i>signed char unsigned char signed char *</i>
<b><br>
h</b> <i>short unsigned short short *</i> <b><br>
l</b> (ell) <i>long unsigned long long *</i> <b><br>
ll</b> (ell ell) <i>long long unsigned long long long long
*</i> <b><br>
j</b> <i>intmax_t uintmax_t intmax_t *</i> <b><br>
t</b> <i>ptrdiff_t</i> (see note) <i>ptrdiff_t *</i> <b><br>
z</b> (see note) <i>size_t</i> (see note) <b><br>
q</b> <i>(deprecated) quad_t u_quad_t quad_t *</i></p>

<p style="margin-left:12%; margin-top: 1em">Note: the
<b>t</b> modifier, when applied to a <b>o</b>, <b>u</b>,
<b>x</b>, or <b>X</b> conversion, indicates that the
argument is of an unsigned type equivalent in size to a
<i>ptrdiff_t</i>. The <b>z</b> modifier, when applied to a
<b>d</b> or <b>i</b> conversion, indicates that the argument
is of a signed type equivalent in size to a <i>size_t</i>.
Similarly, when applied to an <b>n</b> conversion, it
indicates that the argument is a pointer to a signed type
equivalent in size to a <i>size_t</i>.</p>

<p style="margin-left:12%; margin-top: 1em">The following
length modifier is valid for the <b>a</b>, <b>A</b>,
<b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, or
<b>G</b> conversion:</p>

<p style="margin-left:60%; margin-top: 1em"><b>Modifier
a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>,
<b>g</b>, <b>G <br>
l</b> (ell) <i>double</i> (ignored, same behavior as without
it) <b><br>
L</b> <i>long double</i></p>

<p style="margin-left:12%; margin-top: 1em">The following
length modifier is valid for the <b>c</b> or <b>s</b>
conversion:</p>

<p style="margin-left:56%; margin-top: 1em"><b>Modifier c s
<br>
l</b> (ell) <i>wint_t wchar_t *</i></p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">A character that specifies the
type of conversion to be applied.</p>

<p style="margin-left:6%; margin-top: 1em">A field width or
precision, or both, may be indicated by an asterisk
&lsquo;*&rsquo; or an asterisk followed by one or more
decimal digits and a &lsquo;$&rsquo; instead of a digit
string. In this case, an <i>int</i> argument supplies the
field width or precision. A negative field width is treated
as a left adjustment flag followed by a positive field
width; a negative precision is treated as though it were
missing. If a single format directive mixes positional (nn$)
and non-positional arguments, the results are undefined.</p>

<p style="margin-left:6%; margin-top: 1em">The conversion
specifiers and their meanings are:</p>

<p style="margin-top: 1em"><b>diouxX</b></p>

<p style="margin-left:17%; margin-top: 1em">The <i>int</i>
(or appropriate variant) argument is converted to signed
decimal (<b>d</b> and <b>i</b>), unsigned octal (<b>o</b>),
unsigned decimal (<b>u</b>), or unsigned hexadecimal
(<b>x</b> and <b>X</b>) notation. The letters
&lsquo;&lsquo;abcdef&rsquo;&rsquo; are used for <b>x</b>
conversions; the letters &lsquo;&lsquo;ABCDEF&rsquo;&rsquo;
are used for <b>X</b> conversions. The precision, if any,
gives the minimum number of digits that must appear; if the
converted value requires fewer digits, it is padded on the
left with zeros.</p>

<p style="margin-top: 1em"><b>DOU</b></p>

<p style="margin-left:17%; margin-top: 1em">The <i>long
int</i> argument is converted to signed decimal, unsigned
octal, or unsigned decimal, as if the format had been
<b>ld</b>, <b>lo</b>, or <b>lu</b> respectively. These
conversion characters are deprecated, and will eventually
disappear.</p>

<p style="margin-top: 1em"><b>eE</b></p>

<p style="margin-left:17%; margin-top: 1em">The
<i>double</i> argument is rounded and converted in the style
[</p>

<p>&minus; ]<i>d</i>.<i>ddd</i>e&plusmn;<i>dd</i> where
there is one digit before the decimal-point character and
the number of digits after it is equal to the precision; if
the precision is missing, it is taken as 6; if the precision
is zero, no decimal-point character appears. An <b>E</b>
conversion uses the letter &lsquo;E&rsquo; (rather than
&lsquo;e&rsquo;) to introduce the exponent. The exponent
always contains at least two digits; if the value is zero,
the exponent is 00.</p>

<p style="margin-left:17%; margin-top: 1em">For <b>a</b>,
<b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>,
and <b>G</b> conversions, positive and negative infinity are
represented as inf and -inf respectively when using the
lowercase conversion character, and INF and -INF
respectively when using the uppercase conversion character.
Similarly, NaN is represented as nan when using the
lowercase conversion, and NAN when using the uppercase
conversion.</p>

<p style="margin-top: 1em"><b>fF</b></p>

<p style="margin-left:17%; margin-top: 1em">The
<i>double</i> argument is rounded and converted to decimal
notation in the style [</p>

<p>&minus; ]<i>ddd</i>.<i>ddd</i>, where the number of
digits after the decimal-point character is equal to the
precision specification. If the precision is missing, it is
taken as 6; if the precision is explicitly zero, no
decimal-point character appears. If a decimal point appears,
at least one digit appears before it.</p>

<p style="margin-top: 1em"><b>gG</b></p>

<p style="margin-left:17%; margin-top: 1em">The
<i>double</i> argument is converted in style <b>f</b> or
<b>e</b> (or <b>F</b> or <b>E</b> for <b>G</b> conversions).
The precision specifies the number of significant digits. If
the precision is missing, 6 digits are given; if the
precision is zero, it is treated as 1. Style <b>e</b> is
used if the exponent from its conversion is less than
&minus;4 or greater than or equal to the precision. Trailing
zeros are removed from the fractional part of the result; a
decimal point appears only if it is followed by at least one
digit.</p>

<p style="margin-top: 1em"><b>aA</b></p>

<p style="margin-left:17%; margin-top: 1em">The
<i>double</i> argument is rounded and converted to
hexadecimal notation in the style [</p>

<p>&minus; ]0x<i>h</i>.<i>hhhp</i>[ <br>
&plusmn; ]<i>d</i>, where the number of digits after the
hexadecimal-point character is equal to the precision
specification. If the precision is missing, it is taken as
enough to represent the floating-point number exactly, and
no rounding occurs. If the precision is zero, no
hexadecimal-point character appears. The <b>p</b> is a
literal character &lsquo;p&rsquo;, and the exponent consists
of a positive or negative sign followed by a decimal number
representing an exponent of 2. The <b>A</b> conversion uses
the prefix &lsquo;&lsquo;0X&rsquo;&rsquo; (rather than
&lsquo;&lsquo;0x&rsquo;&rsquo;), the letters
&lsquo;&lsquo;ABCDEF&rsquo;&rsquo; (rather than
&lsquo;&lsquo;abcdef&rsquo;&rsquo;) to represent the hex
digits, and the letter &lsquo;P&rsquo; (rather than
&lsquo;p&rsquo;) to separate the mantissa and exponent.</p>

<p style="margin-left:17%; margin-top: 1em">Note that there
may be multiple valid ways to represent floating-point
numbers in this hexadecimal format. For example, 0x1.92p+1,
0x3.24p+0, 0x6.48p-1, and 0xc.9p-2 are all equivalent.
FreeBSD&nbsp;8.0 and later always prints finite non-zero
numbers using &lsquo;1&rsquo; as the digit before the
hexadecimal point. Zeroes are always represented with a
mantissa of 0 (preceded by a &lsquo;-&rsquo; if appropriate)
and an exponent of +0.</p>

<p style="margin-top: 1em"><b>C</b></p>

<p style="margin-left:17%; margin-top: 1em">Treated as
<b>c</b> with the <b>l</b> (ell) modifier.</p>

<p style="margin-top: 1em"><b>c</b></p>

<p style="margin-left:17%; margin-top: 1em">The <i>int</i>
argument is converted to an <i>unsigned char</i>, and the
resulting character is written.</p>

<p style="margin-left:17%; margin-top: 1em">If the <b>l</b>
(ell) modifier is used, the <i>wint_t</i> argument shall be
converted to a <i>wchar_t</i>, and the (potentially
multi-byte) sequence representing the single wide character
is written, including any shift sequences. If a shift
sequence is used, the shift state is also restored to the
original state after the character.</p>

<p style="margin-top: 1em"><b>S</b></p>

<p style="margin-left:17%; margin-top: 1em">Treated as
<b>s</b> with the <b>l</b> (ell) modifier.</p>

<p style="margin-top: 1em"><b>s</b></p>

<p style="margin-left:17%; margin-top: 1em">The <i>char
*</i> argument is expected to be a pointer to an array of
character type (pointer to a string). Characters from the
array are written up to (but not including) a terminating
NUL character; if a precision is specified, no more than the
number specified are written. If a precision is given, no
null character need be present; if the precision is not
specified, or is greater than the size of the array, the
array must contain a terminating NUL character.</p>

<p style="margin-left:17%; margin-top: 1em">If the <b>l</b>
(ell) modifier is used, the <i>wchar_t *</i> argument is
expected to be a pointer to an array of wide characters
(pointer to a wide string). For each wide character in the
string, the (potentially multi-byte) sequence representing
the wide character is written, including any shift
sequences. If any shift sequence is used, the shift state is
also restored to the original state after the string. Wide
characters from the array are written up to (but not
including) a terminating wide NUL character; if a precision
is specified, no more than the number of bytes specified are
written (including shift sequences). Partial characters are
never written. If a precision is given, no null character
need be present; if the precision is not specified, or is
greater than the number of bytes required to render the
multibyte representation of the string, the array must
contain a terminating wide NUL character.</p>

<p style="margin-top: 1em"><b>p</b></p>

<p style="margin-left:17%; margin-top: 1em">The <i>void
*</i> pointer argument is printed in hexadecimal (as if by
&lsquo;%#x&rsquo; or &lsquo;%#lx&rsquo;).</p>

<p style="margin-top: 1em"><b>n</b></p>

<p style="margin-left:17%; margin-top: 1em">The number of
characters written so far is stored into the integer
indicated by the <i>int *</i> (or variant) pointer argument.
No argument is converted.</p>

<p style="margin-top: 1em"><b>m</b></p>

<p style="margin-left:17%; margin-top: 1em">Print the
string representation of the error code stored in the errno
variable at the beginning of the call, as returned by
strerror(3). No argument is taken.</p>

<p style="margin-top: 1em"><b>%</b></p>

<p style="margin-left:17%; margin-top: 1em">A
&lsquo;%&rsquo; is written. No argument is converted. The
complete conversion specification is &lsquo;%%&rsquo;.</p>

<p style="margin-left:6%; margin-top: 1em">The decimal
point character is defined in the program&rsquo;s locale
(category LC_NUMERIC).</p>

<p style="margin-left:6%; margin-top: 1em">In no case does
a non-existent or small field width cause truncation of a
numeric field; if the result of a conversion is wider than
the field width, the field is expanded to contain the
conversion result.</p>

<p style="margin-top: 1em"><b>RETURN VALUES</b></p>

<p style="margin-left:6%;">These functions return the
number of characters printed (not including the trailing
&lsquo;\0&rsquo; used to end output to strings), except for
<b>snprintf</b>() and <b>vsnprintf</b>(), which return the
number of characters that would have been printed if the
<i>size</i> were unlimited (again, not including the final
&lsquo;\0&rsquo;). These functions return a negative value
if an error occurs.</p>

<p style="margin-top: 1em"><b>EXAMPLES</b></p>

<p style="margin-left:6%;">To print a date and time in the
form &lsquo;&lsquo;Sunday, July 3, 10:02&rsquo;&rsquo;,
where <i>weekday</i> and <i>month</i> are pointers to
strings:</p>

<p style="margin-left:14%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
fprintf(stdout, &quot;%s, %s %d, %.2d:%.2d\n&quot;,</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>weekday, month, day, hour, min);</p></td>
<td width="65%">
</td></tr>
</table>

<p style="margin-left:6%; margin-top: 1em">To print pi to
five decimal places:</p>

<p style="margin-left:14%; margin-top: 1em">#include
&lt;math.h&gt; <br>
#include &lt;stdio.h&gt; <br>
fprintf(stdout, &quot;pi = %.5f\n&quot;, 4 * atan(1.0));</p>

<p style="margin-left:6%; margin-top: 1em">To allocate a
128 byte string and print into it:</p>

<p style="margin-left:14%; margin-top: 1em">#include
&lt;stdio.h&gt; <br>
#include &lt;stdlib.h&gt; <br>
#include &lt;stdarg.h&gt; <br>
char *newfmt(const char *fmt, ...) <br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>char *p;</p></td>
<td width="10%"></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>va_list ap;</p></td>
<td width="10%"></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>if ((p = malloc(128)) == NULL)</p></td>
<td width="10%"></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">
</td>
<td width="10%">


<p>return (NULL);</p></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>va_start(ap, fmt);</p></td>
<td width="10%"></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>(void) vsnprintf(p, 128, fmt, ap);</p></td>
<td width="10%"></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>va_end(ap);</p></td>
<td width="10%"></td>
<td width="55%">
</td></tr>
<tr valign="top" align="left">
<td width="24%"></td>
<td width="11%">


<p>return (p);</p></td>
<td width="10%"></td>
<td width="55%">
</td></tr>
</table>

<p style="margin-left:14%;">}</p>

<p style="margin-top: 1em"><b>COMPATIBILITY</b></p>

<p style="margin-left:6%;">The conversion formats
<b>%D</b>, <b>%O</b>, and <b>%U</b> are not standard and are
provided only for backward compatibility. The conversion
format <b>%m</b> is also not standard and provides the
popular extension from the GNU C library.</p>

<p style="margin-left:6%; margin-top: 1em">The effect of
padding the <b>%p</b> format with zeros (either by the
<b>0</b> flag or by specifying a precision), and the benign
effect (i.e., none) of the <b>#</b> flag on <b>%n</b> and
<b>%p</b> conversions, as well as other nonsensical
combinations such as <b>%Ld</b>, are not standard; such
combinations should be avoided.</p>

<p style="margin-top: 1em"><b>ERRORS</b></p>

<p style="margin-left:6%;">In addition to the errors
documented for the write(2) system call, the <b>printf</b>()
family of functions may fail if:</p>

<p style="margin-top: 1em">[EILSEQ]</p>

<p style="margin-left:31%; margin-top: 1em">An invalid wide
character code was encountered.</p>

<p style="margin-top: 1em">[ENOMEM]</p>

<p style="margin-left:31%; margin-top: 1em">Insufficient
storage space is available.</p>

<p style="margin-top: 1em">[EOVERFLOW]</p>

<p style="margin-left:31%; margin-top: 1em">The <i>size</i>
argument exceeds INT_MAX + 1, or the return value would be
too large to be represented by an <i>int</i>.</p>

<p style="margin-top: 1em"><b>SEE ALSO</b></p>

<p style="margin-left:6%;">printf(1), errno(2),
fmtcheck(3), scanf(3), setlocale(3), strerror(3),
wprintf(3)</p>

<p style="margin-top: 1em"><b>STANDARDS</b></p>

<p style="margin-left:6%;">Subject to the caveats noted in
the <i>BUGS</i> section below, the <b>fprintf</b>(),
<b>printf</b>(), <b>sprintf</b>(), <b>vprintf</b>(),
<b>vfprintf</b>(), and <b>vsprintf</b>() functions conform
to ANSI X3.159-1989
(&lsquo;&lsquo;ANSI&nbsp;C89&rsquo;&rsquo;) and ISO/IEC
9899:1999 (&lsquo;&lsquo;ISO&nbsp;C99&rsquo;&rsquo;). With
the same reservation, the <b>snprintf</b>() and
<b>vsnprintf</b>() functions conform to ISO/IEC 9899:1999
(&lsquo;&lsquo;ISO&nbsp;C99&rsquo;&rsquo;), while
<b>dprintf</b>() and <b>vdprintf</b>() conform to IEEE Std
1003.1-2008 (&lsquo;&lsquo;POSIX.1&rsquo;&rsquo;).</p>

<p style="margin-top: 1em"><b>HISTORY</b></p>

<p style="margin-left:6%;">The functions <b>asprintf</b>()
and <b>vasprintf</b>() first appeared in the GNU C library.
These were implemented by Peter Wemm
&lt;<i>peter@FreeBSD.org</i>&gt; in FreeBSD&nbsp;2.2, but
were later replaced with a different implementation from
OpenBSD&nbsp;2.3 by Todd C. Miller
&lt;<i>Todd.Miller@courtesan.com</i>&gt;. The
<b>dprintf</b>() and <b>vdprintf</b>() functions were added
in FreeBSD&nbsp;8.0. The <b>%m</b> format extension first
appeared in the GNU C library, and was implemented in
FreeBSD&nbsp;12.0.</p>

<p style="margin-top: 1em"><b>BUGS</b></p>

<p style="margin-left:6%;">The <b>printf</b> family of
functions do not correctly handle multibyte characters in
the <i>format</i> argument.</p>

<p style="margin-top: 1em"><b>SECURITY
CONSIDERATIONS</b></p>

<p style="margin-left:6%;">The <b>sprintf</b>() and
<b>vsprintf</b>() functions are easily misused in a manner
which enables malicious users to arbitrarily change a
running program&rsquo;s functionality through a buffer
overflow attack. Because <b>sprintf</b>() and
<b>vsprintf</b>() assume an infinitely long string, callers
must be careful not to overflow the actual space; this is
often hard to assure. For safety, programmers should use the
<b>snprintf</b>() interface instead. For example:</p>

<p style="margin-left:6%; margin-top: 1em">void <br>
foo(const char *arbitrary_string, const char *and_another)
<br>
{</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="10%">


<p>char onstack[8];</p></td>
<td width="73%">
</td></tr>
</table>

<p style="margin-left:6%; margin-top: 1em">#ifdef BAD</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>/*</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>* This first sprintf is bad behavior. Do not use
sprintf!</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>*/</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>sprintf(onstack, &quot;%s, %s&quot;, arbitrary_string,
and_another);</p> </td></tr>
</table>

<p style="margin-left:6%;">#else</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>/*</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>* The following two lines demonstrate better use of</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>* snprintf().</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>*/</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>snprintf(onstack, sizeof(onstack), &quot;%s, %s&quot;,
arbitrary_string,</p> </td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="83%">


<p>and_another);</p></td></tr>
</table>

<p style="margin-left:6%;">#endif <br>
}</p>

<p style="margin-left:6%; margin-top: 1em">The
<b>printf</b>() and <b>sprintf</b>() family of functions are
also easily misused in a manner allowing malicious users to
arbitrarily change a running program&rsquo;s functionality
by either causing the program to print potentially sensitive
data &lsquo;&lsquo;left on the stack&rsquo;&rsquo;, or
causing it to generate a memory fault or bus error by
dereferencing an invalid pointer.</p>

<p style="margin-left:6%; margin-top: 1em"><b>%n</b> can be
used to write arbitrary data to potentially
carefully-selected addresses. Programmers are therefore
strongly advised to never pass untrusted strings as the
<i>format</i> argument, as an attacker can put format
specifiers in the string to mangle your stack, leading to a
possible security hole. This holds true even if the string
was built using a function like <b>snprintf</b>(), as the
resulting string may still contain user-supplied conversion
specifiers for later interpolation by <b>printf</b>().</p>

<p style="margin-left:6%; margin-top: 1em">Always use the
proper secure idiom:</p>


<p style="margin-left:14%; margin-top: 1em">snprintf(buffer,
sizeof(buffer), &quot;%s&quot;, string);</p>

<p style="margin-left:6%; margin-top: 1em">BSD May&nbsp;22,
2018 BSD</p>
<hr>
</body>
</html>
